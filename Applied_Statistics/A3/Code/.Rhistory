#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
# y <- unlist(simulate(simple_lm))
nullmod <- lm( unlist(simulate(simple_lm)) ~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer( unlist(simulate(simple_lm)) ~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
rm(list=ls())  #clear load space
setwd('/Users/lysi2/Documents/UNI_Imperial/Applied_Stats/Assignments/A3/Code')
library(tidyverse)
library(faraway)
library('MASS')
library(car)
library(margins)
source('glmxy.R')
x <- dfrm$x
y <- dfrm$y
myglm <- glm(y~x,family = poisson(link='log'))
summary(myglm)
plot(x,y)
xs <- seq(0,1,by=0.01)
lines(xs,y=exp(myglm$coefficients[1] +myglm$coefficients[2]*xs),col='red')
true_beta <- c(-0.5,-2.5)
est_beta <- c(myglm$coefficients[1],myglm$coefficients[2] )
ff <- t(true_beta) %*% (est_beta)
xs <- seq(0,2.5,by=0.01)
plot(exp(myglm$coefficients[1] +myglm$coefficients[2]*x), y, cex=0.4)
abline(0,1,col='red', lwd=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2)
#d
beta <- myglm$coefficients
x_star <- matrix(data = c(1,0.5), byrow = T, nrow = 2)
invJ <- vcov(myglm)
eta_star <- t(x_star)%*%beta
eta_star_R <- predict(myglm, data.frame(x=x_star))
z_alpha <- function(alpha) c(qnorm((alpha)/2), -qnorm((alpha)/2))
CI <-c(exp(eta_star + z_alpha(0.01)[1]*sqrt(t(x_star)%*%invJ%*%x_star)),
exp(eta_star + z_alpha(0.01)[2]*sqrt(t(x_star)%*%invJ%*%x_star)))
CI
plot(x, residuals(myglm, type='deviance'), cex=0.4, ylab = 'Deviance Residuals')
mean(residuals(myglm, type='deviance')<0)
lm1 <- lm(x ~ 1+as.factor(y))
lm2 <- lmer(x ~ 1 + (1|as.factor(y)), REML = TRUE)
c1 <- as.vector(lm1$coefficients)
#same as
c2 <- ranef(lm2)
plot(c1,as.vector(unlist(c2)), xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5))
abline(0,1)
c2
c1
rm(list=ls())  #clear load space
library(lme4)
my_data <- data.frame(source("xyz.R"))
colnames(my_data) <- c('x','y','z')
my_lm <- lm(y~x, data=my_data)
summary(my_lm)
plot(y ~ x, data=my_data, pch=as.character(z))
abline(my_lm$coefficients[1], my_lm$coefficients[2], col='red', lwd=2)
boxplot(y~z, data=my_data)
means <- aggregate(y ~  z, my_data, mean)
my_lmer <- lmer(y ~ 1+x+(1|z), data = my_data, REML=TRUE)
summary(my_lmer)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
# my_data_2 <- my_data[my_data$z==c('B', 'F', 'H'),]
dim(my_data_2)
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
# y <- unlist(simulate(simple_lm))
nullmod <- lm( unlist(simulate(simple_lm)) ~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer( unlist(simulate(simple_lm)) ~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
rm(list=ls())  #clear load space
setwd('/Users/lysi2/Documents/UNI_Imperial/Applied_Stats/Assignments/A3/Code')
library(tidyverse)
library(faraway)
library('MASS')
library(car)
library(margins)
source('glmxy.R')
x <- dfrm$x
y <- dfrm$y
myglm <- glm(y~x,family = poisson(link='log'))
summary(myglm)
plot(x,y)
xs <- seq(0,1,by=0.01)
lines(xs,y=exp(myglm$coefficients[1] +myglm$coefficients[2]*xs),col='red')
true_beta <- c(-0.5,-2.5)
est_beta <- c(myglm$coefficients[1],myglm$coefficients[2] )
ff <- t(true_beta) %*% (est_beta)
xs <- seq(0,2.5,by=0.01)
plot(exp(myglm$coefficients[1] +myglm$coefficients[2]*x), y, cex=0.4)
abline(0,1,col='red', lwd=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2)
#d
beta <- myglm$coefficients
x_star <- matrix(data = c(1,0.5), byrow = T, nrow = 2)
invJ <- vcov(myglm)
eta_star <- t(x_star)%*%beta
eta_star_R <- predict(myglm, data.frame(x=x_star))
z_alpha <- function(alpha) c(qnorm((alpha)/2), -qnorm((alpha)/2))
CI <-c(exp(eta_star + z_alpha(0.01)[1]*sqrt(t(x_star)%*%invJ%*%x_star)),
exp(eta_star + z_alpha(0.01)[2]*sqrt(t(x_star)%*%invJ%*%x_star)))
CI
plot(x, residuals(myglm, type='deviance'), cex=0.4, ylab = 'Deviance Residuals')
mean(residuals(myglm, type='deviance')<0)
lm1 <- lm(x ~ 1+as.factor(y))
lm2 <- lmer(x ~ 1 + (1|as.factor(y)), REML = TRUE)
c1 <- as.vector(lm1$coefficients)
#same as
c2 <- ranef(lm2)
plot(c1,as.vector(unlist(c2)), xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5))
abline(0,1)
summary(lm1)
summary(lm2)
ds
lm1 <- lm(x ~ 0+as.factor(y))
summary(lm1)
lm2 <- lmer(x ~ 0 + (1|as.factor(y)), REML = FALSE)
summary(lm2)
c1 <- as.vector(lm1$coefficients)
#same as
c2 <- ranef(lm2)
plot(c1,as.vector(unlist(c2)), xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5))
abline(0,1)
plot(y ~ x, data=my_data_2, pch=as.character(z))
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
rm(list=ls())  #clear load space
library(lme4)
my_data <- data.frame(source("xyz.R"))
colnames(my_data) <- c('x','y','z')
my_lm <- lm(y~x, data=my_data)
summary(my_lm)
plot(y ~ x, data=my_data, pch=as.character(z))
abline(my_lm$coefficients[1], my_lm$coefficients[2], col='red', lwd=2)
boxplot(y~z, data=my_data)
means <- aggregate(y ~  z, my_data, mean)
my_lmer <- lmer(y ~ 1+x+(1|z), data = my_data, REML=TRUE)
summary(my_lmer)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
# my_data_2 <- my_data[my_data$z==c('B', 'F', 'H'),]
dim(my_data_2)
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
# y <- unlist(simulate(simple_lm))
nullmod <- lm( unlist(simulate(simple_lm)) ~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer( unlist(simulate(simple_lm)) ~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
d
ds
ds <- numeric(1000)
for (i in 1:1000) {
y <- unlist(simulate(simple_lm))
nullmod <- lm( y~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer( y~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
rm(list=ls())  #clear load space
library(lme4)
my_data <- data.frame(source("xyz.R"))
colnames(my_data) <- c('x','y','z')
my_lm <- lm(y~x, data=my_data)
summary(my_lm)
plot(y ~ x, data=my_data, pch=as.character(z))
abline(my_lm$coefficients[1], my_lm$coefficients[2], col='red', lwd=2)
boxplot(y~z, data=my_data)
means <- aggregate(y ~  z, my_data, mean)
my_lmer <- lmer(y ~ 1+x+(1|z), data = my_data, REML=TRUE)
summary(my_lmer)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
# my_data_2 <- my_data[my_data$z==c('B', 'F', 'H'),]
dim(my_data_2)
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
y <- unlist(simulate(simple_lm))
nullmod <- lm( y~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer( y~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
d
ds <- numeric(1000)
for (i in 1:1000) {
# y <- unlist(simulate(simple_lm))
nullmod <- lm(unlist(simulate(simple_lm))~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer(unlist(simulate(simple_lm))~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
ds <- numeric(1000)
for (i in 1:1000) {
# y <- unlist(simulate(simple_lm))
nullmod <- lm(unlist(simulate(simple_lm))~ 1 , data=my_data_2)
altmod <-  suppressMessages(lmer(unlist(simulate(simple_lm))~ 1+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
d
ds <- numeric(1000)
for (i in 1:1000) {
y_new <- unlist(simulate(simple_lm))
nullmod <- lm(y_new~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer(y_new~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
rm(list=ls())  #clear load space
rm(list=ls())  #clear load space
library(lme4)
my_data <- data.frame(source("xyz.R"))
colnames(my_data) <- c('x','y','z')
my_lm <- lm(y~x, data=my_data)
summary(my_lm)
plot(y ~ x, data=my_data, pch=as.character(z))
abline(my_lm$coefficients[1], my_lm$coefficients[2], col='red', lwd=2)
boxplot(y~z, data=my_data)
means <- aggregate(y ~  z, my_data, mean)
my_lmer <- lmer(y ~ 1+x+(1|z), data = my_data, REML=TRUE)
summary(my_lmer)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
# my_data_2 <- my_data[my_data$z==c('B', 'F', 'H'),]
dim(my_data_2)
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
y_new <- unlist(simulate(simple_lm))
nullmod <- lm(y_new~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer(y_new~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
rm(list=ls())  #clear load space
setwd('/Users/lysi2/Documents/UNI_Imperial/Applied_Stats/Assignments/A3/Code')
library(tidyverse)
library(faraway)
library('MASS')
library(car)
library(margins)
source('glmxy.R')
x <- dfrm$x
y <- dfrm$y
myglm <- glm(y~x,family = poisson(link='log'))
summary(myglm)
plot(x,y)
xs <- seq(0,1,by=0.01)
lines(xs,y=exp(myglm$coefficients[1] +myglm$coefficients[2]*xs),col='red')
true_beta <- c(-0.5,-2.5)
est_beta <- c(myglm$coefficients[1],myglm$coefficients[2] )
ff <- t(true_beta) %*% (est_beta)
xs <- seq(0,2.5,by=0.01)
plot(exp(myglm$coefficients[1] +myglm$coefficients[2]*x), y, cex=0.4)
abline(0,1,col='red', lwd=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2)
#d
beta <- myglm$coefficients
x_star <- matrix(data = c(1,0.5), byrow = T, nrow = 2)
invJ <- vcov(myglm)
eta_star <- t(x_star)%*%beta
eta_star_R <- predict(myglm, data.frame(x=x_star))
z_alpha <- function(alpha) c(qnorm((alpha)/2), -qnorm((alpha)/2))
CI <-c(exp(eta_star + z_alpha(0.01)[1]*sqrt(t(x_star)%*%invJ%*%x_star)),
exp(eta_star + z_alpha(0.01)[2]*sqrt(t(x_star)%*%invJ%*%x_star)))
CI
plot(x, residuals(myglm, type='deviance'), cex=0.4, ylab = 'Deviance Residuals')
mean(residuals(myglm, type='deviance')<0)
lm1 <- lm(x ~ 0+as.factor(y))
summary(lm1)
lm2 <- lmer(x ~ 0 + (1|as.factor(y)), REML = FALSE)
summary(lm2)
c1 <- as.vector(lm1$coefficients)
#same as
c2 <- ranef(lm2)
plot(c1,as.vector(unlist(c2)), xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5))
abline(0,1)
plot(y ~ x, data=my_data_2, pch=as.character(z))
rm(list=ls())  #clear load space
setwd('/Users/lysi2/Documents/UNI_Imperial/Applied_Stats/Assignments/A3/Code')
library(tidyverse)
library(faraway)
library('MASS')
library(car)
library(margins)
source('glmxy.R')
x <- dfrm$x
y <- dfrm$y
myglm <- glm(y~x,family = poisson(link='log'))
summary(myglm)
plot(x,y)
print(myglm$coefficients)
source('glmxy.R')
x <- dfrm$x
y <- dfrm$y
myglm <- glm(y~x,family = poisson(link='log'))
print(myglm$coefficients)
plot(x,y)
xs <- seq(0,1,by=0.01)
lines(xs,y=exp(myglm$coefficients[1] +myglm$coefficients[2]*xs),col='red')
true_beta <- c(-0.5,-2.5)
est_beta <- c(myglm$coefficients[1],myglm$coefficients[2] )
xs <- seq(0,2.5,by=0.01)
plot(exp(myglm$coefficients[1] +myglm$coefficients[2]*x), y, cex=0.4)
abline(0,1,col='red', lwd=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2)
xs <- seq(0,2.5,by=0.01)
plot(exp(myglm$coefficients[1] +myglm$coefficients[2]*x), y,
cex=0.4, xlab='inverse link function of the estimated linear predictors')
abline(0,1,col='red', lwd=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2)
?lines
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2, type=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2, lty=2)
plot(exp(myglm$coefficients[1] +myglm$coefficients[2]*x), y,
cex=0.4, xlab='inverse link function of the estimated linear predictors')
abline(0,1,col='red', lwd=2)
lines(xs, 2/(exp(-(true_beta[1] +
true_beta[2]*(log(xs)-est_beta[1])/est_beta[2]))-1), col='blue', lwd=2, lty=2)
#d
beta <- myglm$coefficients
x_star <- matrix(data = c(1,0.5), byrow = T, nrow = 2)
invJ <- vcov(myglm)
eta_star <- t(x_star)%*%beta
eta_star_R <- predict(myglm, data.frame(x=x_star))
z_alpha <- function(alpha) c(qnorm((alpha)/2), -qnorm((alpha)/2))
CI <-c(exp(eta_star + z_alpha(0.01)[1]*sqrt(t(x_star)%*%invJ%*%x_star)),
exp(eta_star + z_alpha(0.01)[2]*sqrt(t(x_star)%*%invJ%*%x_star)))
CI
plot(x, residuals(myglm, type='deviance'), cex=0.4, ylab = 'Deviance Residuals')
mean(residuals(myglm, type='deviance')<0)
lm1 <- lm(x ~ 0+as.factor(y))
summary(lm1)
plot(y,x)
plot(x,y)
plot(x,y, cex=0.3)
boxplot(x,y)
boxplot(y,x)
boxplot(as.factor(y),x)
boxplot(x,as.factor(y))
boxplot(y,x)
plot(x,y,col = rgb(red = 0, green = 0, blue = 1, alpha = 0.1),
pch = 16, xlab="x", ylab="y")
plot(y,x,col = rgb(red = 0, green = 0, blue = 1, alpha = 0.1),
pch = 16, xlab="x", ylab="y")
lm1 <- lm(x ~ 0+as.factor(y))
summary(lm1)
lm2 <- lmer(x ~ 0 + (1|as.factor(y)), REML = FALSE)
summary(lm2)
c1 <- as.vector(lm1$coefficients)
#same as
c2 <- ranef(lm2)
plot(c1,as.vector(unlist(c2)), xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5))
abline(0,1)
plot(c1,as.vector(unlist(c2)), xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5),
xlab='Coefficients linear model', ylab='Coefficients linear mixed model')
abline(0,1)
plot(as.vector(unlist(c2)),c1, xlim=c(-0.7, 0.7), ylim =c(-0.5,0.5),
ylab='Coefficients linear model', xlab='Coefficients linear mixed model')
abline(0,1)
lm2 <- lmer(x ~ 0 + (1|as.factor(y)), REML = FALSE)
summary(lm2)
c2 <- ranef(lm2)
c2
rm(list=ls())  #clear load space
library(lme4)
my_data <- data.frame(source("xyz.R"))
colnames(my_data) <- c('x','y','z')
my_lm <- lm(y~x, data=my_data)
summary(my_lm)
plot(y ~ x, data=my_data, pch=as.character(z))
abline(my_lm$coefficients[1], my_lm$coefficients[2], col='red', lwd=2)
boxplot(y~z, data=my_data)
means <- aggregate(y ~  z, my_data, mean)
my_lmer <- lmer(y ~ 1+x+(1|z), data = my_data, REML=TRUE)
summary(my_lmer)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
# my_data_2 <- my_data[my_data$z==c('B', 'F', 'H'),]
dim(my_data_2)
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
y_new <- unlist(simulate(simple_lm))
nullmod <- lm(y_new~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer(y_new~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
mean(ds<0.00001)
phat <- mean(ds>d)
phat
sqrt(phat*(1-phat)/1000)
rm(list=ls())  #clear load space
library(lme4)
my_data <- data.frame(source("xyz.R"))
colnames(my_data) <- c('x','y','z')
my_lm <- lm(y~x, data=my_data)
summary(my_lm)
plot(y ~ x, data=my_data, pch=as.character(z))
abline(my_lm$coefficients[1], my_lm$coefficients[2], col='red', lwd=2)
boxplot(y~z, data=my_data)
means <- aggregate(y ~  z, my_data, mean)
my_lmer <- lmer(y ~ 1+x+(1|z), data = my_data, REML=TRUE)
summary(my_lmer)
#d
my_data_2 <- subset(my_data, my_data$z=='B' | my_data$z=='F' | my_data$z=='H')
my_lmer2 <- lmer(y ~ 1+x+(1|z), data = my_data_2,  REML=FALSE)
logLik(my_lmer2)
#e
simple_lm <- lm(y~ 1 + x, data=my_data_2)
logLik(simple_lm)
d <- as.numeric(2*(logLik(my_lmer2)-logLik(simple_lm)))
d
ds <- numeric(1000)
for (i in 1:1000) {
y_new <- unlist(simulate(simple_lm))
nullmod <- lm(y_new~ 1 + x, data=my_data_2)
altmod <-  suppressMessages(lmer(y_new~ 1+x+(1|z),
data = my_data_2,  REML=FALSE))
ds[i] <- as.numeric(2 * (logLik(altmod) - logLik(nullmod)))
}
phat <- mean(ds>d)
phat
sqrt(phat*(1-phat)/1000)
plot(y ~ x, data=my_data_2, pch=as.character(z))
abline(simple_lm$coefficients[1], simple_lm$coefficients[2], col='red', lwd=2)
