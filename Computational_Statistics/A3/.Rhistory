}else{ # M2
if (runif(1)>r2){
# draw 2D RV proposal
# y <- c(rnorm(1, pos[2], s1), rnorm(1, pos[3], s2))
sigma_a <- s1
sigma_b <- s2
y <- rq(pos[2:3])
x <- c(pos[2], pos[3]) # prev state RV
# MH step as before
if (runif(1) <= min(exp(f(y) - f(x)),1)){
n_acc <- n_acc+1
x<-y}
pos[c(2,3)] <- x
}else{##trans-dimensional move: R2 to R1
# prev beta proposal
y <- pos[3]
x <- c(pos[2], pos[3])
alpha <- min(1, (r1/r2)*(exp(f2(y) - f(x)))*(dnorm(y, 0, s3 ))  )
if (runif(1)<alpha)
n_acc <- n_acc+1
pos <- c(1,y)
}
}
path[[length(path)+1]] <- pos
}
print(n_acc/N)
return(path)
}
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.0009)
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.001, "red", 'blue'))
#change this
m1 <- 0; m2 <- 0;
for (i in 1:length(path)){
pp <- path[i]
if (pp[1][[1]][1] == 2){
m2 <- m2 + 1
} else {
m1 <- m1 + 1
}
}
m1
m2
rev_jump <- function(N,r1,r2, init, s1, s2, s3 ){
n_acc <- 0 #acceptance rate
#M2
pos <- c(1, init) #Starting value; first component: dimension-1
path <- list() ##chain positions are stored in a list as points have variable dimension
for (i in 1:N){
if (pos[1]==1){ # M1
if (runif(1)>r1){
# this is beta
x <- pos[2]
#simple 1d proposal
y <- rnorm(1, pos[2], s2)
if (runif(1) <= min(exp(f2(y) - f2(x)),1)){
n_acc <- n_acc+1
x<-y
}
pos[2] <- x
}else{ ##trans-dimensional move
# new param (alpha) proposal
u <- rnorm(1, mean=0, sd= s3)
# proposal state
y <- c(u, pos[2])
phi <- dnorm(u,0, s3)
alpha <- min(1, (exp(f(y) - f2(pos[2])))*(r2/r1)*(1/phi)  )
if (runif(1)<alpha){
n_acc <- n_acc+1
pos <- c(2,u,pos[2])
}
}
}else{ # M2
if (runif(1)>r2){
# draw 2D RV proposal
# y <- c(rnorm(1, pos[2], s1), rnorm(1, pos[3], s2))
sigma_a <- s1
sigma_b <- s2
y <- rq(pos[2:3])
x <- c(pos[2], pos[3]) # prev state RV
if (runif(1) <= min(exp(f(y) - f(x)),1)){
n_acc <- n_acc+1
x<-y}
pos[c(2,3)] <- x
}else{
y <- pos[3]
# alpha, beta
x <- c(pos[2], pos[3])
alpha <- min(1, (r1/r2)*(exp(f2(y) - f(x)))*(dnorm(y, 0, s3 ))  )
if (runif(1)<alpha)
n_acc <- n_acc+1
pos <- c(1,y)
}
}
path[[length(path)+1]] <- pos
}
print(n_acc/N)
return(path)
}
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.0009)
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.001, "red", 'blue'))
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.009)
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.001, "red", 'blue'))
#change this
m1 <- 0; m2 <- 0;
for (i in 1:length(path)){
pp <- path[i]
if (pp[1][[1]][1] == 2){
m2 <- m2 + 1
} else {
m1 <- m1 + 1
}
}
m1
m2
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
7957/2043
7957/1e4
count(pos[1,] >= -0.0001)
sum(pos[1,] >= -0.0001)
m1
m2
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.0009)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)
sum(pos[1,] >= -0.0001)/N
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.09)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)/N
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.000009)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)/N
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.0009)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)/N
rev_jump <- function(N,r1,r2, init, s1, s2, s3 ){
n_acc <- 0 #acceptance rate
#M2
pos <- c(1, init) #Starting value; first component: dimension-1
path <- list() ##chain positions are stored in a list as points have variable dimension
for (i in 1:N){
if (pos[1]==1){ # M1
if (runif(1)>r1){
# this is beta
x <- pos[2]
#simple 1d proposal
y <- rnorm(1, pos[2], s2)
if (runif(1) <= min(exp(f2(y) - f2(x)),1)){
n_acc <- n_acc+1
x<-y
}
pos[2] <- x
}else{ ##trans-dimensional move
# new param (alpha) proposal
u <- rnorm(1, mean=0, sd= s3)
# proposal state
y <- c(u, pos[2])
phi <- dnorm(u,0, s3)
alpha <- min(1, (exp(f(y) - f2(pos[2])))*(r2/r1)*(1/phi)  )
if (runif(1)<alpha){
n_acc <- n_acc+1
pos <- c(2,u,pos[2])
}
}
}else{ # M2
if (runif(1)>r2){
# draw 2D RV proposal
y <- c(rnorm(1, pos[2], s1), rnorm(1, pos[3], s2))
# sigma_a <- s1
# sigma_b <- s2
# y <- rq(pos[2:3])
x <- c(pos[2], pos[3]) # prev state RV
if (runif(1) <= min(exp(f(y) - f(x)),1)){
n_acc <- n_acc+1
x<-y}
pos[c(2,3)] <- x
}else{
y <- pos[3]
# alpha, beta
x <- c(pos[2], pos[3])
alpha <- min(1, (r1/r2)*(exp(f2(y) - f(x)))*(dnorm(y, 0, s3 ))  )
if (runif(1)<alpha)
n_acc <- n_acc+1
pos <- c(1,y)
}
}
path[[length(path)+1]] <- pos
}
print(n_acc/N)
return(path)
}
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.0001,0.08, 0.0009)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)/N
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.001,0.08, 0.0009)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)/N
set.seed(222)
path <- rev_jump(1e4,0.5,0.5,1,0.01,0.08, 0.0009)
#set the unknown aalpha to just 0.
pos <- sapply(path, function(x) if(x[1] == 1) c(0,x[2]) else x[-1])
par(mfrow=c(1,1))
# plot(pos[1,1:30], pos[2,1:30], type="l", xlab="alpha", ylab="beta",main="First 30 steps")
plot(pos[1,], pos[2,], pch=16, xlab="alpha",ylab="beta", cex=0.5,
# col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5),
col= ifelse(pos[1,] >= -0.0001, "red", 'blue'))
sum(pos[1,] >= -0.0001)/N
m1 <- 0; m2 <- 0;
for (i in 1:length(path)){
pp <- path[i]
if (pp[1][[1]][1] == 2){
m2 <- m2 + 1
} else {
m1 <- m1 + 1
}
}
m1
m2
set.seed(222)
stat_values <- c(1,0.5,0.8,0.3)
chains <- lapply(stat_values, function(i) mcmc(rev_jump(1e4,0.5,0.5,i,0.0001,0.08, 0.0009)[-(1:500)]))
traceplot(chains, xlab='iterations', ylab='omega')
chains <- mcmc.list(chains)
gelman.diag(chains)
rm(list=ls())  #clear loadspace
setwd("/Users/lysi2/Documents/UNI_Imperial/CompStats/Assignments/A3")
library(coda)
library(mvtnorm)
dat <- read.csv("01389741.csv")
y <- dat$y
t <- dat$t
omega <- pi/10
f <- function(theta, omega=pi/10) {
sum(dnorm(y, theta[1]*t + theta[2]*cos(omega*t), sd=sqrt(0.1), log=T)) +
dt(theta[1], 5, log=TRUE) + dt(theta[2], 5, log=TRUE)
}
sigma_a = 0.01
sigma_b = 0.8
# sd_rand = 0.01
rho = 0
rq <- function(x) {
rmvnorm(1, mean=c(x[1],x[2]), sigma=matrix(
c(sigma_a^2, rho*sigma_a*sigma_b,  rho*sigma_a*sigma_b, sigma_b^2), 2
))}
q <- function(x,y) {
dmvnorm(c(y[1],y[2]), mean=c(x[1], x[2]), sigma=matrix(c(sigma_a^2,
rho*sigma_a*sigma_b,  rho*sigma_a*sigma_b, sigma_b^2),2),log=TRUE)
}
set.seed(222)
my_MH <- function(n, init){
xall <- matrix(NA,nrow=2,ncol=n+1)
x <- init
# print(x)
xall[,1] <- x
for(i in 1:n){
y <- rq(x)
# print(q(y,x)/q(x,y))
if (runif(1)<exp(f(y) - f(x))*(q(y,x)/q(x,y))){
x <- y
}
xall[,i+1] <- x
}
return(xall)
}
# for(i in 1:n){
#   y <- rq(x)
#   if (runif(1)<exp(f(y) - f(x))*(q(y,x)/q(x,y))){
#     x <- y
#   }
#   xall[,i+1] <- x
# }
N = 1e4
my_chains_a <- matrix(rep(NA,(N+1)*4), nrow = N+1, ncol = 4)
my_chains_b <- matrix(rep(NA,(N+1)*4), nrow = N+1, ncol = 4)
count <- 0
stat_values = list(c(0,0), c(-0.05, 0.4), c(0.05, 1.2), c(0.03, 1.5))
for (init in stat_values){
count = count +1
set.seed(222)
xall <- my_MH(N,init)
cat('Chain ', count, 'ESS: ', effectiveSize(t(xall)), '\n')
print(dim(xall))
acf(t(xall))
my_chains_a[,count] <- xall[1,]
my_chains_b[,count] <- xall[2,]
par(mfrow=c(1,1))
plot(xall[1,500:10000], xall[2,500:10000], col=rgb(red=0, green=0, blue=1, alpha=0.14),
xlab='alpha', ylab= 'beta')
cat('Finished stat value ', count, '\n')
}
par(mfrow=c(1,2))
plot(my_chains_a[,1],type='l', ylim=c(-0.06, 0.06), ylab='alpha',
xlab='iterations')
for (i in 2:4){
print(i)
lines(my_chains_a[,i], col=i)
}
plot(my_chains_b[,1],type='l', ylim=c(-0.5, 2), ylab='beta', xlab='iterations')
for (i in 2:4){
print(i)
lines(my_chains_b[,i], col=i)
}
post <- data.frame(my_chains_a[,2], my_chains_b[,2])
colnames(post) <- c('alpha','beta')
#Q4
ahat <- mean(post$alpha[-seq(1000)])
bhat <- mean(post$beta[-seq(1000)])
ahat
bhat
#Q5
t=55
p_y_star <- function(y,t){
# a = sample(post$alpha,1)
# b = sample(post$beta,1)
mean(dnorm(y,mean=ahat*t +bhat*cos(omega*t),  sd=sqrt(0.1)))
# mean(dnorm(y,mean=a*t +b*cos(omega*t),  sd=sqrt(0.1)))
}
all_y <- seq(-1.5,1.5,by=0.005)
t=55
post_y_star <- sapply(all_y, p_y_star, t)
print(post_y_star)
par(mfrow=c(1,1))
plot(all_y, post_y_star, type='l',
ylab='Posterior Predictive Distribution', xlab='y')
e_y_star <- function(y,t){
(y*dnorm(y,mean=ahat*t +bhat*cos(omega*t), sd=sqrt(0.1)))
}
eew <- function(t){
ys <- seq(-1.5,1.5,by=0.05)
all_p <- c()
count <- 0
# p_y <- sapply(ys, p_y_star, t)
e_y <- sapply(ys, e_y_star, t)
# print(e_y)
# print(e_y)
# for (y in ys){
#   count = count +1
#   print(p_y_star(y,t))
#   all_p[count] <- p_y_star(y,t)
#
# }
return(3*sum(e_y)/length(ys))
}
all_t <- seq(1,60,1)
emetos <- sapply(all_t, eew)
# plot(all_t,y)
plot(all_t, emetos, col='red', type='l', ylim=c(-1.5, 1.5),
ylab='E(Y*)', xlab='t')
points(y)
#a
t.test(post$alpha,conf.level = 0.95)
post$alpha
rm(list=ls())  #clear loadspace
setwd("/Users/lysi2/Documents/UNI_Imperial/CompStats/Assignments/A3")
library(coda)
library(mvtnorm)
dat <- read.csv("01389741.csv")
y <- dat$y
t <- dat$t
omega <- pi/10
# Q2
f <- function(theta, omega=pi/10) {
sum(dnorm(y, theta[1]*t + theta[2]*cos(omega*t), sd=sqrt(0.1), log=T)) +
dt(theta[1], 5, log=TRUE) + dt(theta[2], 5, log=TRUE)
}
sigma_a = 0.01
sigma_b = 0.8
rho = 0
rq <- function(x) {
rmvnorm(1, mean=c(x[1],x[2]), sigma=matrix(
c(sigma_a^2, rho*sigma_a*sigma_b,  rho*sigma_a*sigma_b, sigma_b^2), 2
))}
q <- function(x,y) {
dmvnorm(c(y[1],y[2]), mean=c(x[1], x[2]), sigma=matrix(c(sigma_a^2,
rho*sigma_a*sigma_b,  rho*sigma_a*sigma_b, sigma_b^2),2),log=TRUE)
}
set.seed(222)
my_MH <- function(n, init){
xall <- matrix(NA,nrow=2,ncol=n+1)
x <- init
# print(x)
xall[,1] <- x
for(i in 1:n){
y <- rq(x)
# print(q(y,x)/q(x,y))
if (runif(1)<exp(f(y) - f(x))*(q(y,x)/q(x,y))){
x <- y
}
xall[,i+1] <- x
}
return(xall)
}
N = 1e4
my_chains_a <- matrix(rep(NA,(N+1)*4), nrow = N+1, ncol = 4)
my_chains_b <- matrix(rep(NA,(N+1)*4), nrow = N+1, ncol = 4)
count <- 0
stat_values = list(c(0,0), c(-0.05, 0.4), c(0.05, 1.2), c(0.03, 1.5))
chains <- lapply(stat_values, function(i) mcmc(my_MH(N,i)[-(1:500)]))
traceplot(chains, xlab='iterations', ylab='omega')
j
chains <- mcmc.list(chains)
gelman.diag(chains)
rm(list=ls())  #clear loadspace
dat <- read.csv("01389741.csv")
y <- dat$y
t <- dat$t
ahat <- -0.008788731
bhat <- 1.072566
ssss <- seq(0,pi,0.001)
set.seed(222)
f <- function(theta) {
# print(theta*t)
my_thingy <- sum(dnorm(y, ahat*t + bhat*cos(theta*t),
sd=sqrt(0.1), log=TRUE)) + dunif(theta, 0, pi, log=TRUE)
# return(exp(my_thingy))
return(my_thingy)
}
plot(ssss,sapply(ssss, f), type='l')
q <- function(x,y) dnorm(log(y),log(x),sdprop)/y
rq <- function(x) x*exp(rnorm(1,0,sdprop))
my_MH <- function(n, init){
xall <- matrix(NA,nrow=1,ncol=n+1)
x <- init
n_acc <- 0 #acceptance rate
# print(x)
xall[,1] <- x
for(i in 1:n){
y <- rq(x)
# print(q(y,x)/q(x,y))
if (runif(1)<exp(f(y) - f(x))*(q(y,x)/q(x,y))){
x <- y
n_acc <- n_acc+1
}
xall[,i+1] <- x
}
print(n_acc/n)
return(xall)
}
#both work
sdprop = 0.005
# sdprop = 0.01
set.seed(222)
par(mfrow=c(1,2))
N = 1e4
xall0 <- my_MH(N,0.4)
xall1 <- my_MH(N,0.38)
xall2 <- my_MH(N,0.33)
xall3 <- my_MH(N,0.31)
xall3
xall3[1,]
